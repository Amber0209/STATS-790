---
title: "design"
output: html_document
date: "2025-05-10"
---

```{r setup, include=FALSE}
source("tomgro.r")
library(edibble)
library(magrittr)
library(tibble)
library(dplyr)
library(MuMIn)
library(MASS)
```

```{r}
# Construct a full-factorial design of experimental conditions.
# - Manure percentage ranges from 0% to 100% in steps of 10%.
# - Both tomato types (cherry and heirloom) are included.
# - Temperature decreases from 28°C to 21°C across 7 evenly spaced levels.
# - PPFD (light intensity) increases from 140 to 200 across 7 evenly spaced levels.
# This generates every possible combination of these factors (a grid of treatments).
#
# A unique unit identifier ("P1", "P2", ...) is then assigned to each row,
# representing an experimental plot or unit in the design.
design_df <- expand.grid(
  percent_manure = seq(0, 100, by = 10), 
  plant_type = c("cherry", "heirloom"),
  temperature = seq(28, 21, length.out = 7),
  PPFD = seq(140, 200, length.out = 7)
) %>%
  mutate(unit = paste0("P", 1:n()))

```

```{r}
# Apply the tomgro_single function to each row of the design and combine results into a data frame
results <- do.call(rbind, apply(design_df, 1, function(row){
  tomgro_single(
    T_mean = as.numeric(row["temperature"]),
    PPFD_mean = as.numeric(row["PPFD"]),
    percent_manure = as.numeric(row["percent_manure"]),
    plant_type = as.character(row["plant_type"])
  )
}))

# Rename columns to match original variable names
names(results)[names(results) == "T_mean"] <- "temperature"
names(results)[names(results) == "PPFD_mean"] <- "PPFD"

```


```{r}
# Convert plant_type to a factor variable
results$plant_type <- as.factor(results$plant_type)

# Subset data for cherry tomatoes only
cherry_data <- subset(results, plant_type == "cherry")

# Fit a linear model with second-order and interaction terms
model_cherry <- lm(fruit_dry_weight ~ 
                               percent_manure + I(percent_manure^2) +
                               temperature + I(temperature^2) +
                               PPFD +
                               percent_manure:temperature + I(percent_manure^2):temperature +
                               percent_manure:PPFD + I(percent_manure^2):PPFD +
                               temperature:PPFD,data = cherry_data)

options(na.action = "na.fail") # Set NA handling for model selection

# Run model selection using dredge to find the best model
model.cherry.dredge <- dredge(model_cherry)

# Extract the best model (lowest AIC) from dredge results
model.cherry.best.dredge <- get.models(model.cherry.dredge, 1)[[1]]

# Show summary of the best model
summary(model.cherry.best.dredge)

```

```{r}
# Subset data for heirloom tomatoes only
heirloom_data <- subset(results, plant_type == "heirloom")

# Fit a linear model with second-order and interaction terms
model_heirloom <-lm(fruit_dry_weight ~ 
                               percent_manure + I(percent_manure^2) +
                               temperature + I(temperature^2) +
                               PPFD +
                               percent_manure:temperature + I(percent_manure^2):temperature +
                               percent_manure:PPFD + I(percent_manure^2):PPFD +
                               temperature:PPFD, data = heirloom_data)

# Run model selection using dredge to find the best model
model.heirloom.dredge <- dredge(model_heirloom)

# Extract the best model (lowest AIC) from dredge results
model.heirloom.best.dredge <- get.models(model.heirloom.dredge, 1)[[1]]

# Show summary of the best model
summary(model.heirloom.best.dredge)

```


```{r}
# Extract the right-hand side of the best model formula as a character string
formula_cherry <- as.character(formula(model.cherry.best.dredge))[3]

# Convert the string to a one-sided formula (without response variable)
formula_cherry <- as.formula(paste("~", formula_cherry))

# Display the final formula
formula_cherry

```

```{r}
# Extract the right-hand side of the best model formula as a character string
formula_heirloom <- as.character(formula(model.heirloom.best.dredge))[3]

# Convert the string to a one-sided formula (without response variable)
formula_heirloom <- as.formula(paste("~", formula_heirloom))

# Display the final formula
formula_heirloom

```

```{r}
# Set the factor order for plant_type
results$plant_type <- factor(results$plant_type, levels = c("cherry", "heirloom"))

# Fit a full linear model including main effects, quadratic terms, two-way, and three-way interactions
full_model <- lm(fruit_dry_weight ~ plant_type * (percent_manure + temperature + PPFD)
                     + I(percent_manure^2) * (plant_type + temperature + PPFD)
                     + I(temperature^2)
                     + temperature:PPFD,
                     data = results)


options(na.action = "na.fail") # Set NA handling for model selection

# Perform model selection to find the best model
dd <- dredge(full_model)

# Extract the best model (lowest AIC) from dredge results
model_best <- get.models(dd, 1)[[1]]

# Show summary of the best model
summary(model_best)

```
```{r}
# Extract the formula of the best model
best_formula <- formula(model_best)

# Reformulate as a one-sided formula (remove the response variable)
best_formula <- reformulate(attr(terms(best_formula), "term.labels"))

# Display the final formula
best_formula

```
```{r}
# Save the model formulas for later use.
save(
  formula_heirloom,formula_cherry,best_formula,
  file = "formula.RData"
)
```

```{r}
# Define a helper function to clean input data frames.
# The function removes any rows where manure percentage or plant type is missing (NA),
# ensuring only complete and valid records are kept for analysis.
.prepare_df <- function(df) {
  df[!is.na(df$percent_manure) & !is.na(df$plant_type), , drop = FALSE]
}
```

```{r}
# Function to compute the D-optimality (log-determinant per parameter) for a given design and formula
compute_d_optimality <- function(design_df, formula) {
  design_df <- .prepare_df(design_df)
  model_matrix <- model.matrix(formula, data = design_df)
  XtX <- crossprod(model_matrix)  
  p <- ncol(model_matrix)        

  log_det <- determinant(XtX, logarithm = TRUE)$modulus
  d_opt <- log_det / p     

  return(as.numeric(d_opt))
}
```

```{r}
# Function to compute A-optimality (average variance of parameter estimates) for a given design and formula
compute_a_optimality <- function(design_df, formula) {
  design_df <- .prepare_df(design_df)
  model_matrix <- model.matrix(formula, data = design_df)
  XtX <- crossprod(model_matrix)
  p <- ncol(model_matrix)
  inv_XtX <- solve(XtX)
  a_opt <- sum(diag(inv_XtX)) / p  

  return(as.numeric(a_opt))
}
```

```{r}
# Function to compute G-optimality (maximum prediction variance) for a given design and formula
compute_g_optimality <- function(design_df, formula) {
  design_df <- .prepare_df(design_df)
  model_matrix <- model.matrix(formula, data = design_df)
  XtX <- crossprod(model_matrix)
  inv_XtX <- solve(XtX)

  pred_vars <- rowSums((model_matrix %*% inv_XtX) * model_matrix) 
  g_opt <- max(pred_vars) 

  return(as.numeric(g_opt))
}
```

```{r}
# Define the grid size as 7 rows by 7 columns.
rows <- 7
cols <- 7

# Assign temperature values decreasing from 28°C to 21°C, repeated across columns so each row shares the same temperature.
temperature <- rep(seq(28, 21, length.out = rows), times = cols)

# Assign light intensity values increasing from 140 to 200, repeated down rows so each column shares the same PPFD.
PPFD <- rep(seq(140, 200, length.out = cols), each = rows)

# Create a data frame of all row–column combinations to represent the experimental grid layout.
env_data <- expand.grid(
  row = 1:rows,
  col = 1:cols
)

# Attach temperature and PPFD values to each grid cell in the design.
env_data$temperature <- temperature
env_data$PPFD <- PPFD

# Define coordinates of “bad plots” (locations to be excluded due to missing conditions).
idx <- cbind(
  c(5, 5, 5, 4, 4, 4, 1:7), 
  c(1:3, 5:7, rep(4,7))
)
# Identify the row indices in env_data corresponding to those bad plot coordinates.
bad_rows <- apply(idx, 1, function(rc) {
  which(env_data$row == rc[1] & env_data$col == rc[2])
}) |> unlist()
# Mark bad plots by setting their temperature and PPFD values to NA (missing).
env_data$temperature[bad_rows] <- NA
env_data$PPFD[bad_rows] <- NA
# Label each plot with a unique name based on its row and column (e.g., "R1C1").
env_data$plot_name <- paste0("R", env_data$row, "C", env_data$col)


```

```{r}
# Save the full environmental grid (with bad plots marked) as an RData file for later use.
save(
  env_data,
  file = "env_data.RData"
)
```

```{r}
# Function to generate multiple random single-variety designs (cherry or heirloom)
simulate_designs <- function(env_data, n_seed, plant_type_label, n_designs = 1000) {
  # Identify all available plots with non-missing temperature and PPFD
  available_idx <- which(!is.na(env_data$temperature) & !is.na(env_data$PPFD))
  
  replicate(n_designs, {
    # Randomly select 5 manure levels, always including 0
    manure_levels <- c(0, sort(sample(1:100, 4)))
    
    # Randomly select n_seed available plots
    idx <- sample(available_idx, n_seed)
    
    # Assign manure levels to the selected plots
    percent_manure <- rep(NA, nrow(env_data))
    assigned <- rep(manure_levels, length.out = n_seed)
    percent_manure[idx] <- sample(assigned)
    
    # Assign plant type to the selected plots
    plant_type <- rep(NA, nrow(env_data))
    plant_type[idx] <- plant_type_label
    
    # Return the completed design as a data frame
    df <- env_data
    df$percent_manure <- percent_manure
    df$plant_type <- plant_type
    df
  }, simplify = FALSE)
}

# Function to generate multiple random mixed-variety designs (cherry + heirloom)
simulate_designs_mixed <- function(env_data, n_cherry = 18, n_heirloom = 18, n_designs = 1000) {
  # Identify all available plots with non-missing temperature and PPFD
  available_idx <- which(!is.na(env_data$temperature) & !is.na(env_data$PPFD))
  
  # Count total number of available plots
  n_available <- length(available_idx)
  
  replicate(n_designs, {
    # Randomly select 5 manure levels, always including 0
    manure_levels <- c(0, sort(sample(1:100, 4)))
    
    # Randomly select plots for both cherry and heirloom
    idx <- sample(available_idx, n_cherry + n_heirloom) 
    cherry_idx <- idx[1:n_cherry]
    heirloom_idx <- idx[(n_cherry+1):(n_cherry+n_heirloom)]
    
    # Initialize manure assignment and plant type
    percent_manure <- rep(NA, nrow(env_data))
    plant_type <- rep(NA, nrow(env_data))
    
    # Assign manure treatments to cherry and heirloom plots
    percent_manure[cherry_idx]   <- rep(manure_levels, length.out = n_cherry) |> sample()
    percent_manure[heirloom_idx] <- rep(manure_levels, length.out = n_heirloom) |> sample()
    
    # Assign plant type labels
    plant_type[cherry_idx]   <- "cherry"
    plant_type[heirloom_idx] <- "heirloom"
    
    # Return the completed design as a data frame
    df <- env_data
    df$percent_manure <- percent_manure
    df$plant_type <- factor(plant_type, levels = c("cherry", "heirloom"))
    df
  }, simplify = FALSE)
}

# Set a reproducible random seed for consistent results
set.seed(123)

# Generate 1000 random designs for cherry-only, heirloom-only, and mixed scenarios
cherry_designs   <- simulate_designs(env_data, 30, "cherry", n_designs = 1000)
heirloom_designs <- simulate_designs(env_data, 30, "heirloom", n_designs = 1000)
mixed_designs    <- simulate_designs_mixed(env_data, 18, 18, n_designs = 1000)

```

```{r}
# Save the simulated designs (cherry, heirloom, mixed) for later use
save(
  cherry_designs, heirloom_designs, mixed_designs,
  file = "simulation_design.RData"
)

```

```{r}
# Wrapper function to safely run a computation and return NA if it fails
safe_compute <- function(f, ...) {
  tryCatch(f(...), error = function(e) NA)
}

# Function to identify the golden standard (best) design from a list
get_golden_standard <- function(design_list, formula) {
  # Compute D-optimality scores for all designs
  D_scores <- sapply(design_list, function(d) safe_compute(compute_d_optimality, d, formula))
  # Compute A-optimality scores for all designs
  A_scores <- sapply(design_list, function(d) safe_compute(compute_a_optimality, d, formula))
  # Compute G-optimality scores for all designs
  G_scores <- sapply(design_list, function(d) safe_compute(compute_g_optimality, d, formula))

  # Identify designs with valid scores
  valid <- is.finite(D_scores) & is.finite(A_scores) & is.finite(G_scores)
  if (sum(valid) == 0) stop("No valid designs for this scenario and formula!")

  # Extract valid scores and designs
  Dv <- D_scores[valid]; Av <- A_scores[valid]; Gv <- G_scores[valid]
  designs_valid <- design_list[valid]

  # Convert raw scores into efficiency measures (scaled between 0 and 1)
  D_eff <- exp(Dv) / max(exp(Dv), na.rm = TRUE)   # Convert log(D) back to D
  A_eff <- min(Av, na.rm = TRUE) / Av
  G_eff <- min(Gv, na.rm = TRUE) / Gv

  # Compute overall efficiency by summing D-, A-, and G-efficiency
  overall <- D_eff + A_eff + G_eff
  best_idx <- which.max(overall)

  # Return the best design and its associated scores
  list(
    design = designs_valid[[best_idx]],
    scores = data.frame(
      D_log = Dv[best_idx],
      D = exp(Dv[best_idx]), 
      A = Av[best_idx],
      G = Gv[best_idx],
      D_eff = D_eff[best_idx]*100,
      A_eff = A_eff[best_idx]*100,
      G_eff = G_eff[best_idx]*100,
      overall = overall[best_idx]
    )
  )
}

# Select the golden standard design for each scenario with its corresponding formula
golden_cherry_df   <- get_golden_standard(cherry_designs,   formula_cherry)
golden_heirloom_df <- get_golden_standard(heirloom_designs, formula_heirloom)
golden_mixed_df    <- get_golden_standard(mixed_designs,    best_formula)

# Extract D-optimality values (log scale) for each golden design
golden_cherry_D <- golden_cherry_df$scores$D_log
golden_heirloom_D <- golden_heirloom_df$scores$D_log
golden_mixed_D <- golden_mixed_df$scores$D_log

# Extract A-optimality values for each golden design
golden_cherry_A <- golden_cherry_df$scores$A
golden_heirloom_A <- golden_heirloom_df$scores$A
golden_mixed_A <- golden_mixed_df$scores$A

# Extract G-optimality values for each golden design
golden_cherry_G <- golden_cherry_df$scores$G
golden_heirloom_G <- golden_heirloom_df$scores$G
golden_mixed_G <- golden_mixed_df$scores$G

# Combine the golden design scores into a summary table across scenarios
Golden_opt_summary <- rbind(
  cbind(Scenario = "Cherry",   golden_cherry_df$scores),
  cbind(Scenario = "Heirloom", golden_heirloom_df$scores),
  cbind(Scenario = "Mixed",    golden_mixed_df$scores)
)

# Display the summary of golden standard optimality values
Golden_opt_summary

```

```{r}
# Save the full golden standard design objects (data and scores) for all scenarios
save(
  golden_cherry_df, golden_heirloom_df, golden_mixed_df,
  file = "golden_df.RData"
)

```

```{r}
# Save the extracted D-, A-, and G-optimality values for each golden standard design
save(
  golden_cherry_D, golden_cherry_A, golden_cherry_G,
  golden_heirloom_D, golden_heirloom_A, golden_heirloom_G,
  golden_mixed_D, golden_mixed_A, golden_mixed_G,
  file = "golden_optimality.RData"
)

```

```{r}
# Function to generate multiple Completely Randomized Designs (CRDs)
generate_crd_designs <- function(env_data, 
                                 n_designs = 50, 
                                 formula, 
                                 plant_type_label = c("cherry", "heirloom")) {
  
  # Initialize lists to store designs and their optimality scores
  designs <- vector("list", n_designs)
  dopt <- numeric(n_designs)
  aopt <- numeric(n_designs)
  gopt <- numeric(n_designs)
  
  # Identify available plots with valid temperature and PPFD
  available_idx <- which(!is.na(env_data$temperature) & !is.na(env_data$PPFD))
  
  for (i in seq_len(n_designs)) {
    # Fix random seed for reproducibility of each design
    set.seed(i)
    
    # Randomly choose 5 manure levels including 0
    manure_levels <- c(0, sample(1:100, 4, replace = FALSE))
    
    # Create all treatment combinations of manure and plant type
    trt_combos <- expand.grid(
      percent_manure = manure_levels,
      plant_type = plant_type_label,
      stringsAsFactors = FALSE
    )
    
    # Define maximum number of seeds depending on single vs. mixed variety
    if (length(plant_type_label) == 1) {
      max_seeds <- 30  
    } else {
      max_seeds <- 36  
    }
    
    # Determine the maximum number of replicates per treatment
    n_treatments <- length(manure_levels) * length(plant_type_label)
    max_n_reps <- floor(max_seeds / n_treatments)
    if (max_n_reps < 1) next
    
    # Randomly choose the number of replicates and calculate required units
    n_reps <- sample(1:max_n_reps, 1)
    n_units <- n_treatments * n_reps
    
    # Randomly assign plots from the available grid
    chosen_idx <- sample(available_idx, n_units)
    df <- env_data[chosen_idx, ]
    
    # Assign randomized treatment combinations to chosen plots
    trt_df <- trt_combos[rep(1:n_treatments, each = n_reps), ]
    trt_df <- trt_df[sample(nrow(trt_df)), ]
    df$percent_manure <- trt_df$percent_manure
    df$plant_type <- factor(trt_df$plant_type, levels = c("cherry", "heirloom"))
    
    # Compute D-, A-, and G-optimality scores
    dopt[i] <- tryCatch(compute_d_optimality(df, formula), error = function(e) NA)
    aopt[i] <- tryCatch(compute_a_optimality(df, formula), error = function(e) NA)
    gopt[i] <- tryCatch(compute_g_optimality(df, formula), error = function(e) NA)
    
    # Store design and its scores
    designs[[i]] <- df
  }
  
  # Return all generated designs and their scores
  list(
    designs = designs,
    d_opt = dopt,
    a_opt = aopt,
    g_opt = gopt
  )
}


```

```{r}
# Generate 50 CRD designs for cherry-only scenario
CRD_cherry <- generate_crd_designs(env_data, n_designs = 100, 
                                   formula = formula_cherry, 
                                   plant_type_label = "cherry")

# Identify valid designs with finite optimality scores
valid_idx_cherry <- is.finite(CRD_cherry$d_opt) & 
                    is.finite(CRD_cherry$a_opt) & 
                    is.finite(CRD_cherry$g_opt)

# Extract valid D-, A-, and G-optimality scores
valid_dopt_cherry <- CRD_cherry$d_opt[valid_idx_cherry]
valid_aopt_cherry <- CRD_cherry$a_opt[valid_idx_cherry]
valid_gopt_cherry <- CRD_cherry$g_opt[valid_idx_cherry]

# Calculate D-efficiency relative to golden standard (log scale)
d_eff_cherry <- exp(valid_dopt_cherry - golden_cherry_D) * 100

# Calculate A- and G-efficiency relative to golden standard
a_eff_cherry <- golden_cherry_A / valid_aopt_cherry * 100
g_eff_cherry <- golden_cherry_G / valid_gopt_cherry * 100

# Summarize average efficiency values for cherry-only CRDs
mean_table_cherry <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_cherry, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_cherry, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_cherry, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_cherry, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_cherry, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_cherry, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_cherry, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_cherry, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_cherry, na.rm = TRUE),
  
  row.names = "Cherry"
)



```

```{r}
# Generate 50 CRD designs for heirloom-only scenario
CRD_heirloom <- generate_crd_designs(env_data, n_designs = 100, 
                                     formula = formula_heirloom, 
                                     plant_type_label = "heirloom")

# Identify valid designs with finite optimality scores
valid_idx_heirloom <- is.finite(CRD_heirloom$d_opt) & 
                      is.finite(CRD_heirloom$a_opt) & 
                      is.finite(CRD_heirloom$g_opt)

# Extract valid D-, A-, and G-optimality scores
valid_dopt_heirloom <- CRD_heirloom$d_opt[valid_idx_heirloom]
valid_aopt_heirloom <- CRD_heirloom$a_opt[valid_idx_heirloom]
valid_gopt_heirloom <- CRD_heirloom$g_opt[valid_idx_heirloom]

# Calculate efficiency values relative to golden standard
d_eff_heirloom <- exp(valid_dopt_heirloom - golden_heirloom_D) *100
a_eff_heirloom <- golden_heirloom_A / valid_aopt_heirloom *100
g_eff_heirloom <- golden_heirloom_G / valid_gopt_heirloom *100

# Summarize average efficiency values for heirloom-only CRDs
mean_table_heirloom <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_heirloom, na.rm = TRUE),
  "D-efficiency (min)" = min(d_eff_heirloom, na.rm = TRUE),
  "D-efficiency (max)" = max(d_eff_heirloom, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_heirloom, na.rm = TRUE),
  "A-efficiency (min)" = min(a_eff_heirloom, na.rm = TRUE),
  "A-efficiency (max)" = max(a_eff_heirloom, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_heirloom, na.rm = TRUE),
  "G-efficiency (min)" = min(g_eff_heirloom, na.rm = TRUE),
  "G-efficiency (max)" = max(g_eff_heirloom, na.rm = TRUE),
  row.names = "Heirloom"
)

```

```{r}
# Generate 50 CRD designs for mixed cherry + heirloom scenario
CRD_mixed <- generate_crd_designs(env_data, n_designs = 100, 
                                  formula = best_formula, 
                                  plant_type_label = c("cherry","heirloom"))

# Identify valid designs with finite optimality scores
valid_idx_mixed <- is.finite(CRD_mixed$d_opt) & 
                   is.finite(CRD_mixed$a_opt) & 
                   is.finite(CRD_mixed$g_opt)

# Extract valid D-, A-, and G-optimality scores
valid_dopt_mixed <- CRD_mixed$d_opt[valid_idx_mixed]
valid_aopt_mixed <- CRD_mixed$a_opt[valid_idx_mixed]
valid_gopt_mixed <- CRD_mixed$g_opt[valid_idx_mixed]

# Calculate efficiency values relative to golden standard
d_eff_mixed <- exp(valid_dopt_mixed - golden_mixed_D)*100
a_eff_mixed <- golden_mixed_A / valid_aopt_mixed*100
g_eff_mixed <- golden_mixed_G / valid_gopt_mixed*100

# Summarize average efficiency values for mixed-variety CRDs
mean_table_mixed <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_mixed, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_mixed, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_mixed, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_mixed, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_mixed, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_mixed, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_mixed, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_mixed, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_mixed, na.rm = TRUE),
  
  row.names = "Mixed"
)

```

```{r}
# Combine the mean efficiency tables from cherry, heirloom, and mixed CRDs
# into a single summary data frame for easier comparison
CRD_mean_summary <- rbind(mean_table_cherry, mean_table_heirloom, mean_table_mixed)

# Display the summarized efficiency values for all scenarios
CRD_mean_summary

```


```{r}
# Function to generate multiple Randomized Complete Block Designs (RCBDs)
generate_rcbd_designs <- function(env_data, n_designs = 100, formula,
                                  plant_type_fixed = c("cherry", "heirloom"),
                                  n_blocks = NULL) {
  
  # Initialize storage for designs and optimality scores
  designs <- vector("list", n_designs)
  dopt <- numeric(n_designs)
  aopt <- numeric(n_designs)
  gopt <- numeric(n_designs)

  # Identify available plots with valid temperature and PPFD
  available_idx <- which(!is.na(env_data$temperature) & !is.na(env_data$PPFD))

  # Define blocks by splitting temperature into n_blocks
  block_map <- data.frame(
    idx = available_idx,
    temperature = env_data$temperature[available_idx],
    block = cut(env_data$temperature[available_idx], breaks = n_blocks, labels = FALSE)
  )

  # Extract unique block identifiers
  unique_blocks <- unique(block_map$block)

  set.seed(123)
  for (i in seq_len(n_designs)) {
    # Randomly select 5 manure levels including 0
    manure_levels <- c(0, sample(1:100, 4, replace = FALSE))

    # Create all treatment combinations of manure × plant type
    trt_combos <- expand.grid(
      percent_manure = manure_levels,
      plant_type = plant_type_fixed,
      stringsAsFactors = FALSE
    )
    n_treatments <- nrow(trt_combos)

    # Initialize design data frame
    design_df <- data.frame()
    
    # Assign treatments within each block
    for (b in unique_blocks) {
      block_units <- block_map$idx[block_map$block == b]
      chosen_idx <- sample(block_units, n_treatments)
      df_block <- env_data[chosen_idx, ]
      df_block$percent_manure <- trt_combos$percent_manure[sample(n_treatments)]
      df_block$plant_type <- factor(trt_combos$plant_type[sample(n_treatments)],
                                    levels = c("cherry", "heirloom"))
      df_block$block <- factor(b)
      design_df <- rbind(design_df, df_block)
    }

    if (nrow(design_df) == 0) next

    # Compute optimality scores
    dopt[i] <- tryCatch(compute_d_optimality(design_df, formula), error = function(e) NA)
    aopt[i] <- tryCatch(compute_a_optimality(design_df, formula), error = function(e) NA)
    gopt[i] <- tryCatch(compute_g_optimality(design_df, formula), error = function(e) NA)

    # Store the generated design
    designs[[i]] <- design_df
  }

  # Return all designs and their associated scores
  list(
    designs = designs,
    d_opt = dopt,
    a_opt = aopt,
    g_opt = gopt
  )
}

```

```{r}
# Generate 50 mixed-variety RCBD designs with 2 blocks
rcbd_result <- generate_rcbd_designs(env_data, n_designs = 100, formula = best_formula, n_blocks = 2)

# Identify valid designs with finite and positive scores
valid_idx_RCBD <- is.finite(rcbd_result$d_opt) &
                  is.finite(rcbd_result$a_opt) & rcbd_result$a_opt > 0 &
                  is.finite(rcbd_result$g_opt) & rcbd_result$g_opt > 0

# Extract valid optimality scores
valid_dopt_RCBD <- rcbd_result$d_opt[valid_idx_RCBD]
valid_aopt_RCBD <- rcbd_result$a_opt[valid_idx_RCBD]
valid_gopt_RCBD <- rcbd_result$g_opt[valid_idx_RCBD]

# Compute efficiencies relative to golden mixed design
d_eff_rcbd <- exp(valid_dopt_RCBD - golden_mixed_D)*100
a_eff_rcbd <- golden_mixed_A / valid_aopt_RCBD*100
g_eff_rcbd <- golden_mixed_G / valid_gopt_RCBD*100

# Summarize average efficiencies for mixed RCBD
mean_table_rcbd <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_rcbd, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_rcbd, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_rcbd, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_rcbd, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_rcbd, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_rcbd, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_rcbd, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_rcbd, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_rcbd, na.rm = TRUE),
  
  row.names = "RCBD-Temp"
)

```

```{r}
# Generate 50 RCBD designs for cherry-only scenario with 3 blocks
rcbd_cherry <- generate_rcbd_designs(
  env_data, 
  n_designs = 50, 
  formula = formula_cherry, 
  plant_type_fixed = "cherry", 
  n_blocks = 3
)

# Identify valid designs
valid_idx_RCBD_cherry <- is.finite(rcbd_cherry$d_opt) &
                         is.finite(rcbd_cherry$a_opt) & rcbd_cherry$a_opt > 0 &
                         is.finite(rcbd_cherry$g_opt) & rcbd_cherry$g_opt > 0

# Extract valid scores
valid_dopt_RCBD_cherry <- rcbd_cherry$d_opt[valid_idx_RCBD_cherry]
valid_aopt_RCBD_cherry <- rcbd_cherry$a_opt[valid_idx_RCBD_cherry]
valid_gopt_RCBD_cherry <- rcbd_cherry$g_opt[valid_idx_RCBD_cherry]

# Compute efficiencies relative to golden cherry design
d_eff_rcbd_cherry <- exp(valid_dopt_RCBD_cherry - golden_cherry_D)*100
a_eff_rcbd_cherry <- golden_cherry_A / valid_aopt_RCBD_cherry*100
g_eff_rcbd_cherry <- golden_cherry_G / valid_gopt_RCBD_cherry*100

# Summarize average efficiencies for cherry-only RCBD
mean_table_rcbd_cherry <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_rcbd_cherry, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_rcbd_cherry, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_rcbd_cherry, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_rcbd_cherry, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_rcbd_cherry, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_rcbd_cherry, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_rcbd_cherry, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_rcbd_cherry, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_rcbd_cherry, na.rm = TRUE),
  
  row.names = "RCBD-Cherry"
)

```

```{r}
# Generate 50 RCBD designs for heirloom-only scenario with 3 blocks
rcbd_heirloom <- generate_rcbd_designs(
  env_data, 
  n_designs = 50, 
  formula = formula_heirloom,  
  plant_type_fixed = "heirloom", 
  n_blocks = 3
)

# Identify valid designs
valid_idx_RCBD_heirloom <- is.finite(rcbd_heirloom$d_opt) &
                           is.finite(rcbd_heirloom$a_opt) & rcbd_heirloom$a_opt > 0 &
                           is.finite(rcbd_heirloom$g_opt) & rcbd_heirloom$g_opt > 0

# Extract valid scores
valid_dopt_RCBD_heirloom <- rcbd_heirloom$d_opt[valid_idx_RCBD_heirloom]
valid_aopt_RCBD_heirloom <- rcbd_heirloom$a_opt[valid_idx_RCBD_heirloom]
valid_gopt_RCBD_heirloom <- rcbd_heirloom$g_opt[valid_idx_RCBD_heirloom]

# Compute efficiencies relative to golden heirloom design
d_eff_rcbd_heirloom <- exp(valid_dopt_RCBD_heirloom - golden_heirloom_D)*100
a_eff_rcbd_heirloom <- golden_heirloom_A / valid_aopt_RCBD_heirloom*100
g_eff_rcbd_heirloom <- golden_heirloom_G / valid_gopt_RCBD_heirloom*100

# Summarize average efficiencies for heirloom-only RCBD
mean_table_rcbd_heirloom <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_rcbd_heirloom, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_rcbd_heirloom, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_rcbd_heirloom, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_rcbd_heirloom, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_rcbd_heirloom, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_rcbd_heirloom, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_rcbd_heirloom, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_rcbd_heirloom, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_rcbd_heirloom, na.rm = TRUE),
  
  row.names = "RCBD-Heirloom"
)

```

```{r}
# Combine efficiency summaries from cherry, heirloom, and mixed RCBDs
mean_table_all <- rbind(
  mean_table_rcbd_cherry,
  mean_table_rcbd_heirloom,
  mean_table_rcbd
)

# Display summarized results for all RCBD scenarios
mean_table_all

```


```{r}
# Function to generate multiple RCBD designs using PPFD as blocks
generate_rcbd_lightblock <- function(env_data,
                                     n_designs = 100,
                                     formula,
                                     plant_type_fixed = c("cherry", "heirloom"),
                                     n_blocks = 3) {
  
  # Create a block map by dividing PPFD values into n_blocks
  block_map <- data.frame(
    idx = which(!is.na(env_data$PPFD)),
    PPFD = env_data$PPFD[!is.na(env_data$PPFD)],
    block = cut(env_data$PPFD[!is.na(env_data$PPFD)], breaks = n_blocks, labels = FALSE)
  )
  unique_blocks <- unique(block_map$block)

  # Initialize storage for designs and optimality scores
  designs <- vector("list", n_designs)
  dopt <- numeric(n_designs)
  aopt <- numeric(n_designs)
  gopt <- numeric(n_designs)

  set.seed(123)
  for (i in seq_len(n_designs)) {
    # Randomly select 5 manure levels including 0
    manure_levels <- c(0, sample(1:100, 4, replace = FALSE))
    
    # Create all treatment combinations of manure × plant type
    trt_combos <- expand.grid(
      percent_manure = manure_levels,
      plant_type = plant_type_fixed,
      stringsAsFactors = FALSE
    )
    n_treatments <- nrow(trt_combos)
    
    # Initialize design data frame
    design_df <- data.frame()
    
    # Assign treatments within each light block
    for (b in unique_blocks) {
      block_units <- block_map$idx[block_map$block == b]
      if (length(block_units) < n_treatments) next
      
      chosen_idx <- sample(block_units, n_treatments, replace = FALSE)
      df_block <- env_data[chosen_idx, ]
      
      # Randomize the treatment order within the block
      trt_df <- trt_combos[sample(n_treatments), ]
      df_block$percent_manure <- trt_df$percent_manure
      df_block$plant_type <- factor(trt_df$plant_type, levels = c("cherry", "heirloom"))
      df_block$block <- factor(b)
      
      design_df <- rbind(design_df, df_block)
    }
    
    if (nrow(design_df) == 0) next
    
    # Compute optimality scores for the generated design
    dopt[i] <- tryCatch(compute_d_optimality(design_df, formula), error = function(e) NA)
    aopt[i] <- tryCatch(compute_a_optimality(design_df, formula), error = function(e) NA)
    gopt[i] <- tryCatch(compute_g_optimality(design_df, formula), error = function(e) NA)
    
    # Store the completed design
    designs[[i]] <- design_df
  }
  
  # Return all designs and their scores
  list(
    designs = designs,
    d_opt = dopt,
    a_opt = aopt,
    g_opt = gopt
  )
}

```

```{r}
# Generate 50 mixed-variety RCBD designs with 2 PPFD blocks
rcbd_light <- generate_rcbd_lightblock(env_data, n_designs = 100, formula = best_formula, n_blocks = 2)

# Identify valid designs with finite and positive scores
valid_idx_light <- is.finite(rcbd_light$d_opt) &
                   is.finite(rcbd_light$a_opt) & rcbd_light$a_opt > 0 &
                   is.finite(rcbd_light$g_opt) & rcbd_light$g_opt > 0

# Extract valid scores
valid_dopt_light <- rcbd_light$d_opt[valid_idx_light]
valid_aopt_light <- rcbd_light$a_opt[valid_idx_light]
valid_gopt_light <- rcbd_light$g_opt[valid_idx_light]

# Compute efficiencies relative to golden mixed design
d_eff_light <- exp(valid_dopt_light - golden_mixed_D)*100
a_eff_light <- golden_mixed_A / valid_aopt_light*100
g_eff_light <- golden_mixed_G / valid_gopt_light*100

# Summarize average efficiencies for mixed RCBD (light blocks)
mean_table_light <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_light, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_light, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_light, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_light, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_light, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_light, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_light, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_light, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_light, na.rm = TRUE),
  
  row.names = "RCBD-Light"
)

```

```{r}
# Generate 50 cherry-only RCBD designs with PPFD as blocks
rcbd_light_cherry <- generate_rcbd_lightblock(
  env_data, 
  n_designs = 100, 
  formula = formula_cherry, 
  plant_type_fixed = "cherry", 
  n_blocks = 6
)

# Identify valid designs
valid_idx_light_cherry <- is.finite(rcbd_light_cherry$d_opt) &
                          is.finite(rcbd_light_cherry$a_opt) & rcbd_light_cherry$a_opt > 0 &
                          is.finite(rcbd_light_cherry$g_opt) & rcbd_light_cherry$g_opt > 0

# Extract valid scores
valid_dopt_light_cherry <- rcbd_light_cherry$d_opt[valid_idx_light_cherry]
valid_aopt_light_cherry <- rcbd_light_cherry$a_opt[valid_idx_light_cherry]
valid_gopt_light_cherry <- rcbd_light_cherry$g_opt[valid_idx_light_cherry]

# Compute efficiencies relative to golden cherry design
d_eff_light_cherry <- exp(valid_dopt_light_cherry - golden_cherry_D)*100
a_eff_light_cherry <- golden_cherry_A / valid_aopt_light_cherry*100
g_eff_light_cherry <- golden_cherry_G / valid_gopt_light_cherry*100

# Summarize average efficiencies for cherry-only RCBD (light blocks)
mean_table_light_cherry <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_light_cherry, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_light_cherry, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_light_cherry, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_light_cherry, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_light_cherry, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_light_cherry, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_light_cherry, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_light_cherry, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_light_cherry, na.rm = TRUE),
  
  row.names = "RCBD-Light-Cherry"
)
```

```{r}
# Generate 50 heirloom-only RCBD designs with PPFD as blocks
rcbd_light_heirloom <- generate_rcbd_lightblock(
  env_data, 
  n_designs = 100, 
  formula = formula_heirloom, 
  plant_type_fixed = "heirloom", 
  n_blocks = 6
)

# Identify valid designs
valid_idx_light_heirloom <- is.finite(rcbd_light_heirloom$d_opt) &
                            is.finite(rcbd_light_heirloom$a_opt) & rcbd_light_heirloom$a_opt > 0 &
                            is.finite(rcbd_light_heirloom$g_opt) & rcbd_light_heirloom$g_opt > 0

# Extract valid scores
valid_dopt_light_heirloom <- rcbd_light_heirloom$d_opt[valid_idx_light_heirloom]
valid_aopt_light_heirloom <- rcbd_light_heirloom$a_opt[valid_idx_light_heirloom]
valid_gopt_light_heirloom <- rcbd_light_heirloom$g_opt[valid_idx_light_heirloom]

# Compute efficiencies relative to golden heirloom design
d_eff_light_heirloom <- exp(valid_dopt_light_heirloom - golden_heirloom_D)*100
a_eff_light_heirloom <- golden_heirloom_A / valid_aopt_light_heirloom*100
g_eff_light_heirloom <- golden_heirloom_G / valid_gopt_light_heirloom*100

# Summarize average efficiencies for heirloom-only RCBD (light blocks)
mean_table_light_heirloom <- data.frame(
  "D-efficiency (mean)" = mean(d_eff_light_heirloom, na.rm = TRUE),
  "D-efficiency (min)"  = min(d_eff_light_heirloom, na.rm = TRUE),
  "D-efficiency (max)"  = max(d_eff_light_heirloom, na.rm = TRUE),
  
  "A-efficiency (mean)" = mean(a_eff_light_heirloom, na.rm = TRUE),
  "A-efficiency (min)"  = min(a_eff_light_heirloom, na.rm = TRUE),
  "A-efficiency (max)"  = max(a_eff_light_heirloom, na.rm = TRUE),
  
  "G-efficiency (mean)" = mean(g_eff_light_heirloom, na.rm = TRUE),
  "G-efficiency (min)"  = min(g_eff_light_heirloom, na.rm = TRUE),
  "G-efficiency (max)"  = max(g_eff_light_heirloom, na.rm = TRUE),
  
  row.names = "RCBD-Light-Heirloom"
)

```

```{r}
# Combine efficiency summaries from cherry, heirloom, and mixed RCBD (light blocks)
mean_table_light_all <- rbind(
  mean_table_light_cherry,
  mean_table_light_heirloom,
  mean_table_light
)

# Display summarized results
mean_table_light_all

```

```{r}
# Define the percentage range of manure from 0% to 100%
perc <- 0:100

# Define yield response functions for cherry and heirloom tomatoes
func <- function(x, type = "cherry") {
  if (type == "cherry") {
    res = (3/5)*x - (1/175)*x^2          # quadratic response for cherry
  } else if (type == "heirloom") {
    res = 4*sqrt(x) - (1/3)*x            # square-root response for heirloom
  }
  return(res)
}

# Create a data frame of manure percentage vs. expected yield for both types
data <- data.frame(
  Percentage = rep(perc, 2),
  value = c(func(perc), func(perc, "heirloom")),
  Type = rep(c("Cherry", "Heirloom"), each = length(perc))
)

# Define threshold ranges for cherry yield:
Cherry_thrived <- range(perc[which(func(perc, "cherry") > 15.5)])   # thriving yield range
Cherry_survived <- range(perc[which(func(perc, "cherry") > 13)])    # survival yield range

# Define threshold ranges for heirloom yield:
Heirloom_thrived <- range(perc[which(func(perc, "heirloom") > 11.5)])  # thriving yield range
Heirloom_survived <- range(perc[which(func(perc, "heirloom") > 10)])   # survival yield range

```

```{r}
# Function to check whether a design's manure levels fall fully within the "thrived" range
check_thrived  <- function(design, scenario) {
  # Convert percent_manure values to numeric and remove zeros
  values <- suppressWarnings(as.numeric(as.character(design$percent_manure)))
  values <- values[values != 0]

  # For cherry-only scenario: check if all values fall within cherry thrived range
  if (scenario == "cherry-only") {
    all(values >= Cherry_thrived[1] & values <= Cherry_thrived[2], na.rm = TRUE)

  # For heirloom-only scenario: check if all values fall within heirloom thrived range
  } else if (scenario == "heirloom-only") {
    all(values >= Heirloom_thrived[1] & values <= Heirloom_thrived[2], na.rm = TRUE)

  # For mixed scenario: check if all values fall within either cherry or heirloom thrived ranges
  } else if (scenario == "mixed") {
    all(values >= Cherry_thrived[1] & values <= Cherry_thrived[2], na.rm = TRUE) ||
    all(values >= Heirloom_thrived[1] & values <= Heirloom_thrived[2], na.rm = TRUE)

  # Default case: return FALSE if scenario is invalid
  } else {
    FALSE
  }
}


# Build a list of data frames summarizing thrived checks and efficiencies for all scenarios
thrived_list <- lapply(names(all_designs), function(scenario_name) {
  designs <- all_designs[[scenario_name]]               # Extract designs for the scenario
  opt_results <- optimality_results[[scenario_name]]    # Extract optimality results for the scenario

  # Construct summary table with thrived status and optimality efficiencies
  data.frame(
    Design_ID = seq_along(designs),                                                  # Design identifier
    has_thrived_all = sapply(designs, function(design) check_thrived(design, scenario_name)), # Thrived check
    D_efficiency = sapply(opt_results, function(res) res$Efficiency$D_efficiency),   # D-efficiency
    A_efficiency = sapply(opt_results, function(res) res$Efficiency$A_efficiency),   # A-efficiency
    G_efficiency = sapply(opt_results, function(res) res$Efficiency$G_efficiency)    # G-efficiency
  )
}) %>% setNames(names(all_designs))   # Assign scenario names to the list


```

```{r}
# Build summary tables of thrived status vs. mean efficiencies for each scenario
thrived_summary_tables <- lapply(names(thrived_list), function(name) {
  thrived_list[[name]] %>%
    # Group designs by whether they fully meet the thrived condition
    group_by(has_thrived_all) %>%
    # Compute average D-, A-, and G-efficiency within each group
    summarise(
      mean_D = mean(D_efficiency, na.rm = TRUE),
      mean_A = mean(A_efficiency, na.rm = TRUE),
      mean_G = mean(G_efficiency, na.rm = TRUE),
      # Count how many designs had complete efficiency values
      n = sum(!is.na(D_efficiency) & !is.na(A_efficiency) & !is.na(G_efficiency)),
      .groups = "drop"
    )
}) %>% setNames(names(thrived_list))   # Assign scenario names to the summary tables

```

```{r}
thrived_summary_tables[["mixed"]]
```

```{r}
thrived_summary_tables[["cherry-only"]]
```

```{r}
thrived_summary_tables[["heirloom-only"]]
```

```{r}
# Function to check whether a design's manure levels fall fully within the "survived" range
check_survived <- function(design, scenario) {
  # Convert percent_manure values to numeric and remove zeros
  values <- suppressWarnings(as.numeric(as.character(design$percent_manure)))
  values <- values[values != 0]

  # For cherry-only scenario: check if all values fall within cherry survived range
  if (scenario == "cherry-only") {
    all(values >= Cherry_survived[1] & values <= Cherry_survived[2], na.rm = TRUE)

  # For heirloom-only scenario: check if all values fall within heirloom survived range
  } else if (scenario == "heirloom-only") {
    all(values >= Heirloom_survived[1] & values <= Heirloom_survived[2], na.rm = TRUE)

  # For mixed scenario: check if all values fall within either cherry or heirloom survived ranges
  } else if (scenario == "mixed") {
    all(values >= Cherry_survived[1] & values <= Cherry_survived[2], na.rm = TRUE) ||
    all(values >= Heirloom_survived[1] & values <= Heirloom_survived[2], na.rm = TRUE)

  # Default case: return FALSE if scenario is invalid
  } else {
    FALSE
  }
}


# Build a list of data frames summarizing survived checks and efficiencies for all scenarios
survived_list <- lapply(names(all_designs), function(scenario_name) {
  designs <- all_designs[[scenario_name]]               # Extract designs for the scenario
  opt_results <- optimality_results[[scenario_name]]    # Extract optimality results for the scenario

  # Construct summary table with survived status and optimality efficiencies
  data.frame(
    Design_ID = seq_along(designs),                                                  # Design identifier
    has_survived_all = sapply(designs, function(design) check_survived(design, scenario_name)), # Survived check
    D_efficiency = sapply(opt_results, function(res) res$Efficiency$D_efficiency),   # D-efficiency
    A_efficiency = sapply(opt_results, function(res) res$Efficiency$A_efficiency),   # A-efficiency
    G_efficiency = sapply(opt_results, function(res) res$Efficiency$G_efficiency)    # G-efficiency
  )
}) %>% setNames(names(all_designs))   # Assign scenario names to the list


# Summarize mean efficiencies grouped by survived status for each scenario
survived_summary_tables <- lapply(names(survived_list), function(name) {
  survived_list[[name]] %>%
    # Group designs by whether they fully meet the survived condition
    group_by(has_survived_all) %>%
    # Compute mean efficiency values within each group
    summarise(
      mean_D = mean(D_efficiency, na.rm = TRUE),
      mean_A = mean(A_efficiency, na.rm = TRUE),
      mean_G = mean(G_efficiency, na.rm = TRUE),
      # Count designs with complete efficiency values
      n = sum(!is.na(D_efficiency) & !is.na(A_efficiency) & !is.na(G_efficiency)),
      .groups = "drop"
    )
}) %>% setNames(names(survived_list))   # Assign scenario names to the summary tables


```


```{r}
survived_summary_tables[["mixed"]]
```

```{r}
survived_summary_tables[["cherry-only"]]
```

```{r}
survived_summary_tables[["heirloom-only"]]
```




